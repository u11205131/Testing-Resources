\documentclass[a4paper]{article}

\title{Project Implementation
\\COS 301 Buzz Project
\\Group: Testing Phase: Resources
\\Version 1.0}

\author{
\\
\\Carla de Beer 95151835
\\Prenolan Govender 13102380
\\Shaun Meintjes 13310896
\\Collins Mphahlele 12211070
\\Dumisani Msiza 12225887
\\Joseph Murray 12030733
\\Sifiso Shabangu 12081622
\\Joseph Potgieter 12003672
\\Johan van Rooyen 11205131
\\
\\
\textit{https://github.com/Carla-de-Beer/Testing-Resources}
\\
\\ University of Pretoria}

\date{24 April 2015}

% Need to compile using XeLATeX to avoid default font
\usepackage{fontspec}
\setmainfont{Arial}
% Graphics settings for .eps files
\usepackage{graphicx}
\usepackage{epstopdf}
\DeclareGraphicsExtensions{.eps}
\usepackage{float}

\begin{document}

\maketitle
% No page number to cover page
\pagenumbering{gobble}
\newpage
% start page numbering
\pagenumbering{arabic}

% Generate Table of Contents

\tableofcontents
\newpage

\section{Introduction}

The purpose of this task was to test the functionality provided by the Resources teams for the Buzz Project.
\\
\\
According to the master specification document, version 0.1, released 13 March 2015 (SOLMS \textit{et al}, 2015), the buzzResources module is used to upload and manage resources like media (e.g. images, video) and documents (e.g. PDF documents, Open Document Format documents). These resources are to be either embedded or linked to in posts.
\\
\\
This team took each of the pre and post-conditions of the required use case, considering the work of both Resources A and Resources B, and tested them for compliance with the functional requirements. 
\\
\\The use case for this team is called \textbf{uploadResource}. In terms of the requirements for this use case, and as defined by the master specification document, users should be able to upload resources such as media files or documents. Any uploaded resource should be accessible by other users who should also be able to specify links to that resource. 
\\
\\The functional requirements preconditions for this use case included the need to
\begin{itemize}
\item detect the mime type
\item check that size constraints are met
\item check that the resource type is supported
\end{itemize}
The functional requirements postconditions for this use case included the need to
\begin{itemize}
\item check that the resource persisted
\item check that the URL for the resource was created
\end{itemize}

\section {Functional Testing}

\subsection {Resources A}
\subsubsection {Pre-condition violations}

\paragraph{getResourcesBySpaceId}
The pre-condition will be that the SpaceID that is sent in as a parameter does exist in the database prior to this execution. There are no violations of this pre-condition.

\paragraph{getResourcesAll}
The pre-condition will be that there exist resources in the database prior to this execution. There are no violations of this pre-condition.

\paragraph{getResourcesRelated}
The pre-condition will be that the appraisal type (RelatedID) that is sent in as a parameter does exist in the database prior to this execution. There are no violations of this pre-condition. 

\subsubsection {Post-condition violations}

\paragraph{getResourcesBySpaceId}
The post-condition will be that the resources that exist in a certain space will be returned. This post-condition fails, because the function queries the database and returns all of the resources in the database, which is incorrect. No exceptions are thrown if the Buzz Space does not exist.

\paragraph{getResourcesAll}
The post-condition will be that all of the resources in the database will be returned. This post-condition holds, and all of the resources are returned.

\paragraph{getResourcesRelated}
The post-condition will be that the resources that exist in the database of the specified appraisal type will be returned. This post-condition fails, because the function queries the database and returns all of the resources in the database, which is incorrect.

\subsubsection {Data structure requirements}

\paragraph{getResourcesBySpaceId}
No data structure requirements mentioned in the service contract, nor does getResourceBySpaceId utilise any data structures.

\paragraph{getResourcesAll}
No data structure requirements mentioned in the service contract, nor does getResourceAll utilise any data structures..

\paragraph{getResourcesRelated}
No data structure requirements mentioned in the service contract, nor does getResourcesRelated utilise any data structures.

\subsection {Resources B}
None of the functions or use cases for Resources B make use of callbacks.

\textit{ "Nearly everything in node uses callbacks […] Callbacks are functions that are executed asynchronously, or at a later time. Instead of the code reading top to bottom procedurally, async programs may execute different functions at different times based on the order and speed that earlier functions like http requests or file system reads happen."}

 %(github.com/maxogden/art-of-node#callbacks).


The implementation code makes an attempt to allow for the creation of modules for export, but since all the functions, including the main use case, are all object or value-returning functions, it can be said that the code fails, outright, all its services contracts. This is due to the fact that the Resources B code, as it currently stands, cannot be unit tested or integrated into the main code framework for the project. 
The Testing Resources B team undertook an attempt to write unit testing code, working with the existing code structure, rather than amending it other than by introducing a callback to the \texttt{uploadResources} function, in order to be able to test the code for compliance with both functional and non-functional requirements. The code did not run and terminated in an error message stating \texttt{“Error: Cannot find module ‘DataBaseStuff’”}. It seems, therefore that one of the modules is missing from the code structure and, as such, the code could not be tested by means of callbacks.
After some rummaging around in the various GitHub branches, squirrelled away in one of the team members’ branches was a section called “Unit Testing Code”. It became clear that this code is intended to be run via node package manager (npm) and ran unit tests for the following options: 
\begin{itemize}
\item	Download valid resource
\item	Download invalid resource
\item	Add a new Resource Type
\item	Remove a Resource Type
\item	Modify a Resource Type
\item	Retrieve Resource Type Constraints
\item	Detect Mime Type
\end{itemize}
In the absence of being able to test via modules and callbacks, the testing team used this unit test code, as provided by the implementation team, for the testing the Resources B section.
\subsubsection {Pre-condition violations}

\paragraph{removeResource}
The pre-condition of removeResource is assumed to refer to the identification number of a resource in the database which should exist prior to this execution. There are no violations of this pre-condition due to error checks being performed to verify whether or not the entry exists.

\subsubsection {Post-condition violations}

\paragraph{removeResource}
The post-condition of removeResource would be the removal of an entry. Due to a lack of unit testing functionality, the post-condition fails as there is no visible indication of removeResource working.

\subsubsection {Data structure requirements}

\paragraph{removeResource}
No data structure requirements mentioned in the service contract, nor does removeResource utilise any data structures.

\section {Non-functional testing / assessment}
\subsection {Resources A}
The use case was tested against the following list of architectural requirements:
\subsubsection {Usability}
\paragraph{getResourcesBySpaceId}
This function is easy and simple to use. The function is called with the Space ID, and a list of the resources for that space is returned.

\paragraph{getResourcesAll}
This function is simple and easy to use. The function is called and all resources within the database is returned.

\paragraph{getResourcesRelated}
This function is simple and easy to use. The function is called and an appraisal type is sent as parameter. All resources of that appraisal type is returned.

\subsubsection {Performance}

\paragraph{getResourcesBySpaceId}
This function does not suffer from performance issues. The performance of this function depends on the connection and communication speed of the database.

\paragraph{getResourcesAll}
This function does not suffer from performance issues. The performance of this function depends on the connection and communication speed of the database.

\paragraph{getResourcesRelated}
This function does not suffer from performance issues. The performance of this function depends on the connection and communication speed of the database.

\subsubsection {Scalability}

\paragraph{getResourcesBySpaceId}
This function does not place any restriction on the possible size of the database, as a list of all resources within a certain space is returned.

\paragraph{getResourcesAll}
This function does not place any restriction on the possible size of the database, as a list of all resources in the database is returned.

\paragraph{getResourcesRelated}
This function does not place any restriction on the possible size of the database, as a list of resources of a certain type is returned.

\subsubsection {Testability}

\paragraph{getResourcesBySpaceId}
This function is easy to test, as it can be tested from the interfaces that was created.

\paragraph{getResourcesAll}
This function is easy to test, as it can be tested from the interfaces that was created.

\paragraph{getResourcesRelated}
This function is easy to test, as it can be tested from the interfaces that was created.

\subsubsection {Security}

\paragraph{getResourcesBySpaceId}
This function is secure, as it only retrieves information from the database, about the resources for a certain space.

\paragraph{getResourcesAll}
This function is secure, as it only retrieves information from the database, about all of the resources in the database.

\paragraph{getResourcesRelated}
This function is secure, as it only retrieves information from the database, about all of the resources of a certain appraisal type.

\subsubsection {Reliability}

\paragraph{getResourcesBySpaceId}
This function is very unreliable, because it does not conform to the post-condition. It returns a list of all of the resources, instead of only returning a list of resources within a certain space.

\paragraph{getResourcesAll}
This function is reliable as it conforms to the post-condition. The function returns a list of all of the resources within the database.

\paragraph{getResourcesRelated}
This function is very unreliable, because it does not conform to the post-condition. It returns a list of all of the resources, instead of only returning a list of resources of a certain appraisal type.

\subsubsection {Reusability}

\paragraph{getResourcesBySpaceId}
This function is reusable, as it retrieves information from the database, about the resources for a certain space. This function can be called and reused throughout the system.

\paragraph{getResourcesAll}
This function is reusable, as it only retrieves information from the database, about all of the resources in the database. This function can be called and reused throughout the system.

\paragraph{getResourcesRelated}
This function is reusable, as it only retrieves information from the database, about all of the resources of a certain appraisal type. This function can be called and reused throughout the system.

\subsubsection {Pluggability}

\paragraph{getResourcesBySpaceId}
This function is pluggable, as it retrieves information from the database, about the resources for a certain space. This function can be called and reused within any system if called on a database that has the same structure as the current database.

\paragraph{getResourcesAll}
This function is reusable, as it only retrieves information from the database, about all of the resources in the database. This function can be called and reused within any system if called on a database that has the same structure as the current database.

\paragraph{getResourcesRelated}
This function is reusable, as it only retrieves information from the database, about all of the resources of a certain appraisal type. This function can be called and reused within any system if called on a database that has the same structure as the current database.


\subsection {Resources B}
The use case was tested against the following list of architectural requirements:
\subsubsection {Usability}

\paragraph{removeResource}
removeResource demonstrates usability by being simple and easy to use. The function only needs be called along with the ID of the resource to be removed which is intuitive.

\subsubsection {Performance}

\paragraph{removeResource}
removeResource does not suffer from any performance issues in and of itself, however should the database maintain a sizeable stature, removeResource will be seen to suffer in performance. This is to be expected.

\subsubsection {Scalability}

\paragraph{removeResource}
removeResource offers no solutions to accomodate an increase or decrease in size of the database.

\subsubsection {Testability}

\paragraph{removeResource}
removeResource has a complete lack of testability due to it not conforming to proper unit testing standards (making use of callbacks, depending on a live database etc.).

\subsubsection {Security}

\paragraph{removeResource}
The only security concern would be an incorrect ID being used in order to remove a different resource than required, potentially putting the system at risk.

\subsubsection {Reliability}

\paragraph{removeResource}
According to the failure of the post-condition, removeResource gives a poor indication with regards to reliability.

\subsubsection {Reusability}

\paragraph{removeResource}
removeResource is not very reusable due to the dependence on a single database. Using this function throughout this system would not be possible/practical.

\subsubsection {Pluggability}

\paragraph{removeResource}
In the same vein as reusability, removeResource cannot be integrated into other systems due to a lack of robustness and versatility.


\section {Critical Evaluation and Recommendations}
\subsection {Resources A}
\subsection {Resources B}
\subsubsection {Code and code structure legibility}
The code has some degree of JSDoc comments, but could have benefited from a more comprehensive commenting system so as to allow newcomers to the code to better understand the program logic. The use of an explanatory README file would also have been welcomed by the testing team and others new to the work to help understand the logic behind the system implemented. Thus, from a code legibility point of view, there are some improvements that can be made to make the existing code more user-friendly. On a positive note, the code does make use of modularisation in the sense the additional functionalities are separated out from the main use case, making it easier to understand, and perhaps also easier to test the code.
In terms of the files themselves, the file structure could have benefited from a better organisational structure. There are files with duplicate naming, for example, residing in different folders, making it unclear how these fit into the existing code structure (it was assume that the code folders in the master branch were the most current).  In addition, the unit testing code was hidden away in a branch and, as such, was not that straightforward to find.


\section {References}
SOLMS, F., PIETERSE V., OMELEZE S., RAMASILA, L. 2015. \textit{Buzz Discussion Board Requirements and Design Specifications (version 0.1)}. Department of Computer Science, University of Pretoria.


\end{document}
